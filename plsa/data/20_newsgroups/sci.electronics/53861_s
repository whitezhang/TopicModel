
 in article <1993apr9.041505.8593@ringer.cs.utsa.edu> djimenez@ringer.cs.utsa.edu (daniel jimenez) writes:
 >suppose we have a boolean function which is a minimal sum-of-products
 >(derived from a k-map or something), like this:
 
 >f(a,b,c,d) = bc'd' + acd' + abc' + ab'c
 >
 >the books on logic design i have consulted all seem to imply that this
 >is where the analysis ends  ...  but by factoring out the
 >`a' term in the function, we can get fewer gates:
 
 >f(a,b,c,d) = bc'd' + a(cd' + bc' + b'c),
 
 >which yields 9 gates. 
 
 	yes, but... the minimization of gates is important in part
 because of timing considerations.  a ttl gate has the basic structure
 of and/or/invert, and an inversion of a sum of a product is just
 exactly one gate delay.  the reason to find a minimal sum of products
 is that this matches a hardware optimization.
 
 	a positive-or gate (such as the 9-gate solution uses) has
 two gate delays (and there's another gate delay in the second term)
 so that the second solution, while simpler in logic symbols, can 
 be expected to be something less than optimal in the real world.
 ecl is similar to ttl, in that it can support an or/and
 gate with the minimum delay (unlike ttl, you get both true and
 inverse outputs for 'free' when using ecl).
 
 	pals are basically large programmable and/or/invert
 gates (with your choice of internal connections between the
 various sections, and perhaps some latches), so a minimum sum
 of products also is a way to shoehorn a logic design into 
 a few pals.  it's not comparably easy to design with a minimization
 of logic gates, but some software packages claim to allow you to
 do so, and will take just about any mess of gates (as a nodelist
 with 74xxx series logic ics) and produce a description of
 a logic cell array to do the same job.  xilinx's xact software
 does this by treating each logic block as a macro, and expanding
 it all out, then simplifying.
 
 	john whitmore
 