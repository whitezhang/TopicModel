
 archive-name: x-faq/part5
 last-modified: 1993/04/04
 
 ----------------------------------------------------------------------
 subject: 119)  i'm writing a widget and can't use a float as a resource value.
 
 float resources are not portable; the size of the value may be larger than
 the size of an xtpointer. try using a pointer to a float instead; the xaw
 scrollbar float resources are handled in this way. 
 
 ----------------------------------------------------------------------
 subject: 120)  is this a memory leak in the x11r4 xtdestroywidget()?!
 
 yes. this is the "unofficial" fix-19 for the x11r4 destroy.c:
 
 *** destroy.c.1.37	thu jul 11 15:41:25 1991
 --- lib/xt/destroy.c	thu jul 11 15:42:23 1991
 ***************
 *** 1,4 ****
 --- 1,5 ----
   /* $xconsortium: destroy.c,v 1.37 90/09/28 10:21:32 swick exp $ */
 + /* plus unofficial patches in revisions 1.40 and 1.41 */
   
   /***********************************************************
   copyright 1987, 1988 by digital equipment corporation, maynard, massachusetts,
 ***************
 *** 221,239 ****
        */
   
       int i = 0;
 !     destroyrec* dr = app->destroy_list;
       while (i < app->destroy_count) {
   	if (dr->dispatch_level >= dispatch_level)  {
   	    widget w = dr->widget;
   	    if (--app->destroy_count)
   		bcopy( (char*)(dr+1), (char*)dr,
 ! 		       app->destroy_count*sizeof(destroyrec)
   		      );
   	    xtphase2destroy(w);
   	}
   	else {
   	    i++;
 - 	    dr++;
   	}
       }
   }
 --- 222,245 ----
        */
   
       int i = 0;
 !     destroyrec* dr;
       while (i < app->destroy_count) {
 + 
 + 	/* xtphase2destroy can result in calls to xtdestroywidget,
 + 	 * and these could cause app->destroy_list to be reallocated.
 + 	 */
 + 
 + 	dr = app->destroy_list + i;
   	if (dr->dispatch_level >= dispatch_level)  {
   	    widget w = dr->widget;
   	    if (--app->destroy_count)
   		bcopy( (char*)(dr+1), (char*)dr,
 ! 		       (app->destroy_count - i) * sizeof(destroyrec)
   		      );
   	    xtphase2destroy(w);
   	}
   	else {
   	    i++;
   	}
       }
   }
 
 [from donna converse, converse@expo.lcs.mit.edu]
 
 ----------------------------------------------------------------------
 subject: 121)  are callbacks guaranteed to be called in the order registered?
 
 	although some books demonstrate that the current implementation of xt
 happens to call callback procedures in the order in which they are registered, 
 the specification does not guarantee such a sequence, and supplemental 
 authoritative documents (i.e. the asente/swick volume) do say that the order is
 undefined.  because the callback list can be manipulated by both the widget and
 the application, xt cannot guarantee the order of execution.
 	in general, the callback procedures should be thought of as operating 
 independently of one another and should not depend on side-effects of other
 callbacks operating; if a seqence is needed, then the single callback to be 
 registered can explicitly call other functions necessary.
 
 [4/92; thanks to converse@expo.lcs.mit.edu]
 
 ----------------------------------------------------------------------
 subject: 122)  why doesn't xtdestroywidget() actually destroy the widget?
 
 	xtdestroywidget() operates in two passes, in order to avoid leaving
 dangling data structures; the function-call marks the widget, which is not 
 actually destroyed until your program returns to its event-loop. 
 
 ----------------------------------------------------------------------
 subject: 123)  how do i query the user synchronously using xt?
 	
 	it is possible to have code which looks like this trivial callback,
 which has a clear flow of control. the calls to askuser() block until answer
 is set to one of the valid values. if it is not a "yes" answer, the code drops
 out of the callback and back to an event-processing loop: 
 
 	void quit(widget w, xtpointer client, xtpointer call)
 	{
 		int             answer;
 		answer = askuser(w, "really quit?");
 		if (ret_yes == answer)
 			{
 			answer = askuser(w, "are you really positive?");
 			if (ret_yes == answer)
 				exit(0);
                 }
 	}
 
 	a more realistic example might ask whether to create a file or whether 
 to overwrite it.
 	this is accomplished by entering a second event-processing loop and
 waiting until the user answers the question; the answer is returned to the
 calling function. that function askuser() looks something like this, where the 
 motif can be replaced with widget-set-specific code to create some sort of 
 dialog-box displaying the question string and buttons for "ok", "cancel" and 
 "help" or equivalents:
 
   int askuser(w, string)
         widget          w;
         char           *string;
   {
         int             answer=ret_none;	/* some not-used marker */
         widget          dialog;			/* could cache&carry, but ...*/
         arg             args[3];
         int             n = 0;
         xtappcontext    context;
 
         n=0;
         xtsetarg(args[n], xmnmessagestring, xmstringcreateltor(string,
                 xmstring_default_charset)); n++;
         xtsetarg(args[n], xmndialogstyle, xmdialog_application_modal); n++;
         dialog = xmcreatequestiondialog(xtparent(w), string, args, n);
         xtaddcallback(dialog, xmnokcallback, response, &answer);
         xtaddcallback(dialog, xmncancelcallback, response, &answer);
         xtaddcallback(dialog, xmnhelpcallback, response, &answer);
         xtmanagechild(dialog);
 
         context = xtwidgettoapplicationcontext (w);
         while (answer == ret_none || xtapppending(context)) {
                 xtappprocessevent (context, xtimall);
         }
         xtdestroywidget(dialog);  /* blow away the dialog box and shell */
         return answer;
   }
 
 	the dialog supports three buttons, which are set to call the same 
 function when tickled by the user.  the variable answer is set when the user 
 finally selects one of those choices:
 
   void response(w, client, call)
         widget          w;
         xtpointer client;
         xtpointer call;
   {
   int *answer = (int *) client;
   xmanycallbackstruct *reason = (xmanycallbackstruct *) call;
         switch (reason->reason) {
         case xmcr_ok:
                 *answer = ret_yes;	/* some #define value */
                 break;
         case xmcr_cancel:
                 *answer = ret_no; 
 		break;
         case xmcr_help:
                 *answer = ret_help;
                 break;
         default:
                 return;
         }
 }
 
 and the code unwraps back to the point at which an answer was needed and
 continues from there.
 
 [thanks to dan heller (argv@sun.com); further code is in dan's r3/contrib
 widgetwrap library. 2/91]
 
 ----------------------------------------------------------------------
 subject: 124)  how do i determine the name of an existing widget?
 i have a widget id and need to know what the name of that widget is.
 
 	users of r4 and later are best off using the xtname() function, which 
 will work on both widgets and non-widget objects.
 
 	if you are still using r3, you can use this simple bit of code to do 
 what you want. note that it depends on the widget's internal data structures 
 and is not necessarily portable to future versions of xt, including r4.
 
 	#include <x11/corep.h>
 	#include <x11/xresource.h>
 	string xtname (widget)
 	widget widget;	/* will work with non-widget objects */
 	{
 	return xrmnametostring(widget->core.xrm_name);
 	}
 
 [7/90; modified with suggestion by larry rogers (larry@boris.webo.dg.com) 9/91]
 
 ----------------------------------------------------------------------
 subject: 125)  why do i get a baddrawable error drawing to xtwindow(widget)?
 i'm doing this in order to get a window into which i can do xlib graphics
 within my xt-based program:
 
 > canvas = xtcreatemanagedwidget ( ...,widgetclass,...) /* drawing area */
 > ...
 > window = xtwindow(canvas);	/* get the window associated with the widget */
 > ...
 > xdrawline (...,window,...);	/* produces error */
 
 	the window associated with the widget is created as a part of the 
 realization of the widget.  using a window id of null ("no window") could 
 create the error that you describe.  it is necessary to call xtrealizewidget() 
 before attempting to use the window associated with a widget. 
 	note that the window will be created after the xtrealizewidget() call, 
 but that the server may not have actually mapped it yet, so you should also 
 wait for an expose event on the window before drawing into it.
 
 ----------------------------------------------------------------------
 subject: 126)  why do i get a badmatch error when calling xgetimage?
 
 the badmatch error can occur if the specified rectangle goes off the edge of 
 the screen. if you don't want to catch the error and deal with it, you can take
 the following steps to avoid the error:
 
 1) make a pixmap the same size as the rectangle you want to capture.
 2) clear the pixmap to background using xfillrectangle.
 3) use xcopyarea to copy the window to the pixmap.
 4) if you get a noexpose event, the copy was clean. use xgetimage to grab the
 image from the pixmap.
 5) if you get one or more graphicsexpose events, the copy wasn't clean, and 
 the x/y/width/height members of the graphicsexpose event structures tell you 
 the parts of the pixmap which aren't good.
 6) get rid of the pixmap; it probably takes a lot of memory.
 
 [10/92; thanks to oliver jones (oj@pictel.com)]
 
 ----------------------------------------------------------------------
 subject: 127)  how can my application tell if it is being run under x?
 
 	a number of programs offer x modes but otherwise run in a straight
 character-only mode. the easiest way for an application to determine that it is
 running on an x display is to attempt to open a connection to the x server:
 	
 	display = xopendisplay(display_name);
 	if (display)
 		{ do x stuff }
 	else
 		{ do curses or something else }
 where display_name is either the string specified on the command-line following
 -display, by convention, or otherwise is (char*)null [in which case 
 xopendisplay uses the value of $display, if set].
 
 this is superior to simply checking for the existence a -display command-line 
 argument or checking for $display set in the environment, neither of which is 
 adequate. [5/91]
 
 ----------------------------------------------------------------------
 subject: 128)  how do i make a "busy cursor" while my application is computing?
 is it necessary to call xdefinecursor() for every window in my application?
 
 	the easiest thing to do is to create a single inputonly window that is 
 as large as the largest possible screen; make it a child of your toplevel 
 window and it will be clipped to that window, so it won't affect any other 
 application. (it needs to be as big as the largest possible screen in case the 
 user enlarges the window while it is busy or moves elsewhere within a virtual 
 desktop.) substitute "toplevel" with your top-most widget here (similar code 
 should work for xlib-only applications; just use your top window):
 
      unsigned long valuemask;
      xsetwindowattributes attributes;
 
      /* ignore device events while the busy cursor is displayed. */
      valuemask = cwdontpropagate | cwcursor;
      attributes.do_not_propagate_mask =  (keypressmask | keyreleasemask |
          buttonpressmask | buttonreleasemask | pointermotionmask);
      attributes.cursor = xcreatefontcursor(xtdisplay(toplevel), xc_watch);
 
      /* the window will be as big as the display screen, and clipped by
         its own parent window, so we never have to worry about resizing */
      xcreatewindow(xtdisplay(toplevel), xtwindow(toplevel), 0, 0,
          65535, 65535, (unsigned int) 0, 0, inputonly,
          copyfromparent, valuemask, &attributes);
 
 where the maximum size above could be replaced by the real size of the screen,
 particularly to avoid servers which have problems with windows larger than
 32767.
 
 when you want to use this busy cursor, map and raise this window; to go back to
 normal, unmap it. this will automatically keep you from getting extra mouse
 events; depending on precisely how the window manager works, it may or may not
 have a similar effect on keystrokes as well.
 
 in addition, note also that most of the xaw widgets support an xtncursor 
 resource which can be temporarily reset, should you merely wish to change the
 cursor without blocking pointer events.
 
 [thanks to andrew wason (aw@cellar.bae.bellcore.com), dan heller 
 (argv@sun.com), and mouse@larry.mcrcim.mcgill.edu; 11/90,5/91]
 
 ----------------------------------------------------------------------
 subject: 129)  how do i fork without hanging my parent x program?
 
 	an x-based application which spawns off other unix processes which 
 continue to run after it is closed typically does not vanish until all of its 
 children are terminated; the children inherit from the parent the open x 
 connection to the display. 
 	what you need to do is fork; then, immediately, in the child process, 
 		close (connectionnumber(xtdisplay(widget)));
 to close the file-descriptor in the display information. after this do your 
 exec. you will then be able to exit the parent.
 	alternatively, before exec'ing make this call, which causes the file 
 descriptor to be closed on exec.
 		(void) fcntl(connectionnumber(xdisplay), f_setfd, 1);
 
 [thanks to janet anstett (anstettj@tramp.colorado.edu), gordon freedman 
 (gjf00@duts.ccc.amdahl.com); 2/91. greg holmberg (holmberg@frame.com), 3/93.]
 
 ----------------------------------------------------------------------
 subject: 130)  can i make xt or xlib calls from a signal handler?
 
 	no. xlib and xt have no mutual exclusion for protecting critical 
 sections. if your signal handler makes such a call at the wrong time (which 
 might be while the function you are calling is already executing), it can leave
 the library in an inconsistent state. note that the ansi c standard points
 out that behavior of a signal handler is undefined if the signal handler calls
 any function other than signal() itself, so this is not a problem specific to
 xlib and xt; the posix specification mentions other functions which may be
 called safely but it may not be assumed that these functions are called by 
 xlib or xt functions.
 	you can work around the problem by setting a flag in the interrupt
 handler and later checking it with a work procedure or a timer event which
 has previously been added.
 
 	note: the article in the x journal 1:4 and the example in o'reilly 
 volume 6 are in error.
 
 [thanks to pete ware (ware@cis.ohio-state.edu) and donna converse 
 (converse@expo.lcs.mit.edu), 5/92]
 
 ----------------------------------------------------------------------
 subject: 131)  what are these "xlib sequence lost" errors?
 
 	you may see these errors if you issue xlib requests from an xlib error 
 handler, or, more likely, if you make calls which generate x requests to xt or 
 xlib from a signal handler, which you shouldn't be doing in any case. 
 
 ----------------------------------------------------------------------
 subject: 132)  how can my xt program handle socket, pipe, or file input?
 
 	it's very common to need to write an xt program that can accept input 
 both from a user via the x connection and from some other file descriptor, but 
 which operates efficiently and without blocking on either the x connection or 
 the other file descriptor.
 	a solution is use xtappaddinput(). after you open your file descriptor,
 use xtappaddinput() to register an input handler. the input handler will be 
 called every time there is something on the file descriptor requiring your 
 program's attention. write the input handler like you would any other xt 
 callback, so it does its work quickly and returns.  it is important to use only
 non-blocking i/o system calls in your input handlers.
 	most input handlers read the file descriptor, although you can have an 
 input handler write or handle exception conditions if you wish.
 	be careful when you register an input handler to read from a disk file.
 you will find that the function is called even when there isn't input pending.
 xtappaddinput() is actually working as it is supposed to. the input handler is 
 called whenever the file descriptor is ready to be read, not only when there is
 new data to be read. a disk file (unlike a pipe or socket) is almost always 
 ready to be read, however, if only because you can spin back to the beginning
 and read data you've read before.  the result is that your function will almost
 always be called every time around xtappmainloop(). there is a way to get the 
 type of interaction you are expecting; add this line to the beginning of your 
 function to test whether there is new data:
 	     if (ioctl(fd, fionread, &n) == -1 || n == 0) return;
 but, because this is called frequently, your application is effectively in a 
 busy-wait; you may be better off not using xtappaddinput() and instead setting 
 a timer and in the timer procedure checking the file for input.
 
 [courtesy dan heller (argv@ora.com), 8/90; mouse@larry.mcrcim.mcgill.edu 5/91;
 ollie jones (oj@pictel.com) 6/92]
 
 ----------------------------------------------------------------------
 subject: 133)  how do i simulate a button press/release event for a widget?
 
 	you can do this using xsendevent(); it's likely that you're not setting
 the window field in the event, which xt needs in order to match to the widget
 which should receive the event.
 	 if you're sending events to your own application, then you can use 
 xtdispatchevent() instead. this is more efficient than xsendevent() in that you
 avoid a round-trip to the server.
 	depending on how well the widget was written, you may be able to call
 its action procedures in order to get the effects you want.
 
 [courtesy mark a. horstman (mh2620@sarek.sbc.com), 11/90]
 
 ----------------------------------------------------------------------
 subject: 134)  why doesn't anything appear when i run this simple program?
 
 > ...
 > the_window = xcreatesimplewindow(the_display,
 >      root_window,size_hints.x,size_hints.y,
 >      size_hints.width,size_hints.height,border_width,
 >      blackpixel(the_display,the_screen),
 >      whitepixel(the_display,the_screen));
 > ...
 > xselectinput(the_display,the_window,exposuremask|buttonpressmask|
 > 	buttonreleasemask);
 > xmapwindow(the_display,the_window);
 > ...
 > xdrawline(the_display,the_window,the_gc,5,5,100,100);
 > ...
 
 	you are right to map the window before drawing into it. however, the 
 window is not ready to be drawn into until it actually appears on the screen --
 until your application receives an expose event. drawing done before that will 
 generally not appear. you'll see code like this in many programs; this code 
 would appear after window was created and mapped:
   while (!done)
     {
       xnextevent(the_display,&the_event);
       switch (the_event.type) {
 	case expose:	 /* on expose events, redraw */
 		xdrawline(the_display,the_window,the_gc,5,5,100,100);
 		break;
 	...
 	}
     }
 
 	note that there is a second problem: some xlib implementations don't 
 set up the default graphics context to have correct foreground/background 
 colors, so this program could previously include this code:
   ...
   the_gc_values.foreground=blackpixel(the_display,the_screen);	/* e.g. */
   the_gc_values.background=whitepixel(the_display,the_screen);	/* e.g. */
   the_gc = xcreategc(the_display,the_window,
                 gcforeground|gcbackground,&the_gc_values);
   ...
  
 note: the code uses blackpixel and whitepixel to avoid assuming that 1 is 
 black and 0 is white or vice-versa.  the relationship between pixels 0 and 1 
 and the colors black and white is implementation-dependent.  they may be 
 reversed, or they may not even correspond to black and white at all.
 
 also note that actually using blackpixel and whitepixel is usually the wrong 
 thing to do in a finished program, as it ignores the user's preference for 
 foreground and background.
 
 and also note that you can run into the same situation in an xt-based program
 if you draw into the xtwindow(w) right after it has been realized; it may
 not yet have appeared.
 
 ----------------------------------------------------------------------
 subject: 135)  what is the difference between a screen and a screen?
 
 	the 'screen' is an xlib structure which includes the information about
 one of the monitors or virtual monitors which a single x display supports. a 
 server can support several independent screens. they are numbered unix:0.0,
 unix:0.1, unix:0.2, etc; the 'screen' or 'screen_number' is the second digit --
 the 0, 1, 2 which can be thought of as an index into the array of available 
 screens on this particular display connection.
 	the macros which you can use to obtain information about the particular
 screen on which your application is running typically have two forms -- one
 which takes a screen and one with takes both the display and the screen_number.
 	in xt-based programs, you typically use xtscreen(widget) to determine 
 the screen on which your application is running, if it uses a single screen.
 	(part of the confusion may arise from the fact that some of the macros
 which return characteristics of the screen have "display" in the names -- 
 xdisplaywidth, xdisplayheight, etc.)
 	
 ----------------------------------------------------------------------
 subject: 136)  can i use c++ with x11? motif? xview?
 	
 	the x11r4/5 header files are compatible with c++. the motif 1.1 header 
 files are usable as is inside extern "c" {...}. however, the definition of
 string in intrinsic.h can conflict with the libg++ or other string class and
 needs to be worked around.
 
 	some other projects which can help:
 	wwl, a set of c++ classes by jean-daniel fekete to wrap x toolkit 
 widgets, available via anonymous ftp from export.lcs.mit.edu as 
 contrib/wwl-1.2.tar.z [7/92] or lri.lri.fr (129.175.15.1) as pub/wwl-1.2.tar.z.
 it works by building a set of c++ classes in parallel to the class tree of the 
 widgets.
 	the c++ interviews toolkit is obtainable via anonymous ftp from 
 interviews.stanford.edu. interviews uses a box/glue model similar to that of 
 tex for constructing user interfaces and supports multiple looks on the user 
 interfaces. some of its sample applications include a wysiwig document editor 
 (doc), a macdraw-like drawing program (idraw) and an interface builder 
 (ibuild).
 	things,  a class library written at the rome air force base by the 
 strategic air command, available as freeware on archive sites.
 
 	motif++ is a public-domain library that defines c++ class wrappers for
 motif 1.1; it adds an "application" class for, e.g., initializing x, and also
 integrates wcl and the xbae widget set. this work was developed by ronald van 
 loon <rvloon@cv.ruu.nl> based on x++, a set of bindings done by the university 
 of lowell graphics research laboratory. the current sources are available from 
 decuac.dec.com (192.5.214.1) as /pub/x11/motif++.21.jul.92.tar.z.
 	
 	the source code examples for doug young's "object-oriented programming 
 with c++ and osf/motif" [isbn 0-13-630252-1] do not include "widget wrappers" 
 but do include a set of classes that encapsulates higher-level facilities 
 commonly needed by motif- or other xt-based applications; check export in
 ~ftp/contrib/young.c++.tar.z.
 	rogue wave offers "view.h++" for c++ programmers using motif; info:
 1-800-487-3217 or +1 503 754 2311.
 	a product called "commonview" by glockenspiel ltd, ireland (??) 
 apparently is a c++-based toolkit for multiple window systems, including pm,
 windows, and x/motif.
 	xv++ is sold by qualix (415-572-0200; fax -1300); it implements an 
 interface from the gil files that sun's openwindows developers guide 3.0 
 produces to xview wrapper classes in c++.
 
 	uit is a set of c++ classes embedding the xview toolkit; it is intended
 for use with sun's openwindows developers guide 3.0 builder tool. sources are 
 on export.mit.edu.au as uit.tar.z. version 2 was released 5/28/92.
 	
 	also of likely use is objectcenter (saber-c++). and a reasonable
 alternative to all of the above is parcplace's (formerly solbourne's) object 
 interface.
 
 [thanks to douglas s. rand (dsrand@mitre.org) and george wu (gwu@tcs.com);2/91]
 
 ----------------------------------------------------------------------
 subject: 137)  where can i obtain alternate language bindings to x?
 
 	versions of the clx lisp bindings are part of the x11 core source 
 distributions. a version of clx is on the r5 tape [10/91]; version 5.0.2 [9/92]
 is on export.lcs.mit.edu in /contrib/clx.r5.02.tar.z.
 
 	the saic ada-x11 bindings are through anonymous ftp in /pub from
 stars.rosslyn.unisys.com (128.126.164.2). 
 	there is an x/ada study team sponsored by nasa jsc, which apparently is
 working out bindings. information: xada@ghg.hou.tx.us.
 	gnu smalltalk has a beta native smalltalk binding to x called stix (by
 steven.byrne@eng.sun.com). it is still in its beginning stages, and 
 documentation is sparse outside the smalltalk code itself. the sources are 
 available as /pub/gnu/smalltalk-1.1.1.tar.z on prep.ai.mit.edu (18.71.0.38) or 
 ugle.unit.no (129.241.1.97).
 	prolog bindings (called "xwip") written by ted kim at ucla while
 supported in part by darpa are available by anonymous ftp from
 export.lcs.mit.edu:contrib/xwip.tar.z or ftp.cs.ucla.edu:pub/xwip.tar.z.
 these prolog language bindings depend on having a quintus-type foreign function
 interface in your prolog. the developer has gotten it to work with quintus and 
 sicstus prolog. inquiries should go to xwip@cs.ucla.edu. [3/90]
 	scheme bindings to xlib, osf/motif, and xaw are part of the elk
 distribution; version 1.5a on export obsoletes the version on the r5 contrib
 tape. 
 	x-scm, a bolt-on accessory for aubrey jaffer's "scm" scheme interpreter
 that provides an interface to xlib, motif, and openlook, is now available via 
 ftp from altdorf.ai.mit.edu:archive/scm/xscm1.05.tar.z and 
 nexus.yorku.ca:pub/scheme/new/xscm1.05.tar.z.
 
 	ada bindings to motif, explicitly, will eventually be made available by
 the jet propulsion laboratories, probably through the normal electronic
 means.  advance information can be obtained from dsouleles@dsfvax.jpl.nasa.gov,
 who may respond as time permits.
 	adamotif is a complete binding to x and motif for the ada language, for
 many common systems; it is based in part upon the saic/unisys bindings and also
 includes a uil to ada translator. info: systems engineering research 
 corporation, 1-800-ada-serc (well!serc@apple.com).
 
 	also: the mit consortium, although not involved in producing ada
 bindings for x, maintains a partial listing of people involved in x and ada;
 information is available from donna converse, converse@expo.lcs.mit.edu.
 
 ----------------------------------------------------------------------
 subject: 138)  can xgetwindowattributes get a window's background pixel/pixmap?
 
 	no.  once set, the background pixel or pixmap of a window cannot be 
 re-read by clients.  the reason for this is that a client can create a pixmap,
 set it to be the background pixmap of a window, and then free the pixmap. the 
 window keeps this background, but the pixmap itself is destroyed.  if you're 
 sure a window has a background pixel (not a pixmap), you can use xcleararea() 
 to clear a region to the background color and then use xgetimage() to read 
 back that pixel.  however, this action alters the contents of the window, and 
 it suffers from race conditions with exposures. [courtesy dave lemke of ncd 
 and stuart marks of sun]
 
 	note that the same applies to the border pixel/pixmap. this is a 
 (mis)feature of the protocol which allows the server is free to manipulate the
 pixel/pixmap however it wants.  by not requiring the server to keep the 
 original pixel or pixmap, some (potentially a lot of) space can be saved. 
 [courtesy jim fulton, mit x consortium]
 
 ----------------------------------------------------------------------
 subject: 139)  how do i create a transparent window?
 	
 	a completely transparent window is easy to get -- use an inputonly
 window. in order to create a window which is *mostly* transparent, you have
 several choices:
 	- the shape extension first released with x11r4 offers an easy way to
 make non-rectangular windows, so you can set the shape of the window to fit the
 areas where the window should be nontransparent; however, not all servers 
 support the extension.
 	- a machine-specific method of implementing transparent windows for
 particular servers is to use an overlay plane supported by the hardware.  note 
 that there is no x notion of a "transparent color index".
 	- a generally portable solution is to use a large number of tiny 
 windows, but this makes operating on the application as a unit difficult.
 	- a final answer is to consider whether you really need a transparent
 window or if you would be satisfied with being able to overlay your application
 window with information; if so, you can draw into separate bitplanes in colors
 that will appear properly.
 
 [thanks to der mouse, mouse@lightning.mcrcim.mcgill.edu, 3/92; see also
 the x journal 1:4 for a more complete answer, including code samples for this
 last option]
 
 ----------------------------------------------------------------------
 subject: 140)  why doesn't gxxor produce mathematically-correct color values?
 
 	when using gxxor you may expect that drawing with a value of black on a
 background of black, for example, should produce white. however, the drawing
 operation does not work on rgb values but on colormap indices. the color that
 the resulting colormap index actually points to is undefined and visually
 random unless you have actually filled it in yourself. [on many x servers black
 and white often 0/1 or 1/0; programs taking advantage of this mathematical
 coincidence will break.]
 	if you want to be combining colors with gxxor, then you should be 
 allocating a number of your own color cells and filling them with your chosen
 pre-computed values.
 	if you want to use gxxor simply to switch between two colors, then you 
 can take the shortcut of setting the background color in the gc (graphics 
 context) to 0 and the foreground color to a value such that when it draws over 
 red, say, the result is blue, and when it draws over blue the result is red. 
 this foreground value is itself the xor of the colormap indices of red and 
 blue.
 
 [thanks to chris flatters (cflatter@zia.aoc.nrao.edu) and ken whaley 
 (whaley@spectre.pa.dec.com), 2/91]
 
 ----------------------------------------------------------------------
 subject: 141)  why does every color i allocate show up as black?
 
 	make sure you're using 16 bits and not 8.  the red, green, and blue 
 fields of an xcolor structure are scaled so that 0 is nothing and 65535 is 
 full-blast. if you forget to scale (using, for example, 0-255 for each color) 
 the xalloccolor function will perform correctly but the resulting color is 
 usually black. 
 
 [thanks to paul asente, asente@adobe.com, 7/91]
 
 ----------------------------------------------------------------------
 subject: 142)  why can't my program get a standard colormap?
 i have an image-processing program which uses xgetrgbcolormap() to get the 
 standard colormap, but it doesn't work. 
 
 	xgetrgbcolormap() when used with the property xa_rgb_default_map does 
 not create a standard colormap -- it just returns one if one already exists.
 use xstdcmap or do what it does in order to create the standard colormap first.
 
 [1/91; from der mouse (mouse@larry.mcrcim.mcgill.edu)]
 
 ----------------------------------------------------------------------
 subject: 143)  why does the pixmap i copy to the screen show up as garbage? 
 
 	the initial contents of pixmaps are undefined.  this means that most
 servers will allocate the memory and leave around whatever happens to be there 
 -- which is usually garbage.  you probably want to clear the pixmap first using
 xfillrectangle() with a function of gxcopy and a foreground pixel of whatever 
 color you want as your background (or 0l if you are using the pixmap as a 
 mask). [courtesy dave lemke of ncd and stuart marks of sun]
 
 ----------------------------------------------------------------------
 subject: 144)  how do i check whether a window id is valid?
 my program has the id of a window on a remote display. i want to check whether
 the window exists before doing anything with it.
 
 	because x is asynchronous, there isn't a guarantee that the window 
 would still exist between the time that you got the id and the time you sent an
 event to the window or otherwise manipulated it. what you should do is send the
 event without checking, but install an error handler to catch any badwindow 
 errors, which would indicate that the window no longer exists. this scheme will
 work except on the [rare] occasion that the original window has been destroyed 
 and its id reallocated to another window.
 
 [courtesy ken lee (klee@synoptics.com), 4/90]
 
 ----------------------------------------------------------------------
 subject: 145)  can i have two applications draw to the same window?
 
 	yes. the x server assigns ids to windows and other resources (actually,
 the server assigns some bits, the client others), and any application that 
 knows the id can manipulate the resource [almost any x server resource, except
 for gcs and private color cells, can be shared].
 	the problem you face is how to disseminate the window id to multiple 
 applications. a simple way to handle this (and which solves the problem of the
 applications' running on different machines) is in the first application to 
 create a specially-named property on the root-window and put the window id into
 it. the second application then retrieves the property, whose name it also
 knows, and then can draw whatever it wants into the window.
 	[note: this scheme works iff there is only one instance of the first
 application running, and the scheme is subject to the limitations mentioned
 in the question about using window ids on remote displays.]
 	note also that you will still need to coordinate any higher-level 
 cooperation among your applications. 
 	note also that two processes can share a window but should not try to 
 use the same server connection. if one process is a child of the other, it 
 should close down the connection to the server and open its own connection.
 
 [mostly courtesy phil karlton (karlton@wpd.sgi.com) 6/90]
 
 ----------------------------------------------------------------------
 subject: 146)  why can't my program work with tvtwm or swm?
 
 	a number of applications, including xwd, xwininfo, and xsetroot, do not
 handle the virtual root window which tvtwm and swm use; they typically return 
 the wrong child of root. a general solution is to add this code or to use it in
 your own application where you would normally use rootwindow(dpy,screen):
 
 /* function name: getvroot
  * description: gets the root window, even if it's a virtual root
  * arguments: the display and the screen
  * returns: the root window for the client
  */
 #include <x11/xatom.h>
 window getvroot(dpy, scr)
 display        *dpy;
 int             scr;
 {
 window          rootreturn, parentreturn, *children;
 unsigned int    numchildren;
 window          root = rootwindow(dpy, scr);
 atom            __swm_vroot = none;
 int             i;
 
   __swm_vroot = xinternatom(dpy, "__swm_vroot", false);
   xquerytree(dpy, root, &rootreturn, &parentreturn, &children, &numchildren);
   for (i = 0; i < numchildren; i++) {
 	atom            actual_type;
 	int             actual_format;
 	long            nitems, bytesafter;
 	window         *newroot = null;
 
 	if (xgetwindowproperty(dpy, children[i], __swm_vroot, 0, 1,
 	    false, xa_window, &actual_type, &actual_format, &nitems,
             &bytesafter, (unsigned char **) &newroot) == success && newroot) {
 			root = *newroot;
 			break;
 		}
 	}
 
 	return root;
 }
 
 [courtesy david elliott (dce@smsc.sony.com). similar code is in ssetroot, a
 version of xsetroot distributed with tvtwm. 2/91]
 
 a header file by andreas stolcke of icsi on export.lcs.mit.edu:contrib/vroot.h 
 functions similarly by providing macros for rootwindow and defaultrootwindow;
 code can include this header file first to run properly in the presence of a
 virtual desktop.
 	
 ----------------------------------------------------------------------
 subject: 147)  how do i keep a window from being resized by the user?
 
 	resizing the window is done through the window manager; window managers
 can pay attention to the size hints your application places on the window, but 
 there is no guarantee that the window manager will listen. you can try setting 
 the minimum and maximum size hints to your target size and hope for the best. 
 [1/91]
 
 ----------------------------------------------------------------------
 subject: 148)  how do i keep a window in the foreground at all times?
 
 	it's rather antisocial for an application to constantly raise itself
 [e.g. by tracking visibilitynotify events] so that it isn't overlapped -- 
 imagine the conflict between two such programs running.  
 	the only sure way to have your window appear on the top of the stack
 is to make the window override-redirect; this means that you are temporarily
 assuming window-management duties while the window is up, so you want to do 
 this infrequently and then only for short periods of time (e.g. for popup 
 menus or other short parameter-setting windows).
 
 [thanks to der mouse (mouse@larry.mcrcim.mcgill.edu); 7/92]
 
 ----------------------------------------------------------------------
 subject: 149)  how do i make text and bitmaps blink in x?
 
 	there is no easy way.  unless you're willing to depend on some sort of
 extension (as yet non-existent), you have to arrange for the blinking yourself,
 either by redrawing the contents periodically or, if possible, by playing games
 with the colormap and changing the color of the contents.
 
 [thanks to mouse@larry.mcrcim.mcgill.edu (der mouse), 7/91]
 
 ----------------------------------------------------------------------
 subject: 150)+ how do i get a double-click in xlib?
 
 	users of xt have the support of the translation manager to help 
 get notification of double-clicking.
 	there is no good way to get only a double-click in xlib, because the 
 protocol does not provide enough support to do double-clicks.  you have to do 
 client-side timeouts, unless the single-click action is such that you can defer
 actually taking it until you next see an event from the server.  thus, you 
 have to do timeouts, which means system-dependent code.  on most unixish 
 implementations, you can use xconnectionnumber to get the file descriptor of 
 the x connection and then use select() or something similar on that.
 	note that many user-interface references suggest that a double-click
 be used to extend the action indicated by a single-click; if this is the case
 in your interface then you can execute the first action and as a compromise
 check the timestamp on the second event to determine whether it, too, should
 be the single-click action or the double-click action.
 
 [thanks to mouse@larry.mcrcim.mcgill.edu (der mouse), 4/93]
 
 ----------------------------------------------------------------------
 subject: 151)! how do i render rotated text?
 	
 	xlib intentionally does not provide such sophisticated graphics 
 capabilities, leaving them up to server-extensions or clients-side graphics
 libraries.
 	your only choice, if you want to stay within the core x protocol, is to
 render the text into a pixmap, read it back via xgetimage(), rotate it "by 
 hand" with whatever matrices you want, and put it back to the server via 
 xputimage(); more specifically:
 	1) create a bitmap b and write your text to it.
 	2) create an xybitmap image i from b (via xgetimage).
 	3) create an xybitmap image i2 big enough to handle the transformation.
 	4) for each x,y in i2, i2(x,y) = i(a,b) where 
 		a = x * cos(theta) - y * sin(theta)
 		b = x * sin(theta) + y * cos(theta)
 	5) render i2
 	note that you should be careful how you implement this not to lose
 bits; an algorithm based on shear transformations may in fact be better.
 	the high-level server-extensions and graphics packages available for x 
 also permit rendering of rotated text: display postscript, pex, phigs, and gks,
 although most are not capable of arbitrary rotation and probably do not use the
 same fonts that would be found on a printer.
 	in addition, if you have enough access to the server to install a font
 on it, you can create a font which consists of letters rotated at some
 predefined angle. your application can then itself figure out placement of each
 glyph.
 
 [courtesy der mouse (mouse@larry.mcrcim.mcgill.edu), eric taylor 
 (etaylor@wilkins.bmc.tmc.edu), and ken lee (klee@synoptics.com), 11/90;
 liam quin (lee@sq.com), 12/90]
 
 	interviews (c++ ui toolkit, in the x contrib software) has support for
 rendering rotated fonts in x.  it could be one source of example code.
 [brian r. smith (brsmith@cs.umn.edu), 3/91]
 	another possibility is to use the hershey fonts; they are 
 stroke-rendered and can be used by x by converting them into xdrawline 
 requests. [eric@pencom.com, 10/91]
 
 	the xrotfont program by alan richardson (mppa3@syma.sussex.ac.uk) 
 (posted to comp.sources.x july 14 1992) paints a rotated font by implementing 
 the method above and by using an outline (hershey) font.
 	the xvertext package by alan richardson (mppa3@syma.sussex.ac.uk) is a 
 set of functions to facilitate the writing of text at any angle.  version 3.0 
 was recently released to alt.sources and comp.sources.misc [3/93]; it is also 
 on export as contrib/xvertext.3.0.shar.z. 
 
 	o'reilly's x resource volume 3 includes information from hp about
 modifications to the x fonts server which provide for rotated and scaled text.
 
 ----------------------------------------------------------------------
 subject: 152)  what is the x registry? (how do i reserve names?)
 
 	there are places in the x toolkit, in applications, and in the x
 protocol that define and use string names. the context is such that conflicts
 are possible if different components use the same name for different things.
 	the mit x consortium maintains a registry of names in these domains:
 orgainization names, selection names, selection targets, resource types,
 application classes, and class extension record types; and several others.
 	the list as of 7/91 is in the directory mit/doc/registry on the r5 
 tape; it is also available by sending "send docs registry" to the xstuff mail
 server.
 	to register names (first come, first served) or to ask questions send 
 to xregistry@expo.lcs.mit.edu; be sure to include a postal address for
 confirmation.
 
 [11/90; condensed from asente/swick appendix h]
 ----------------------------------------------------------------------
 
 
 david b. lewis 					faq%craft@uunet.uu.net
 
 		"just the faqs, ma'am." -- joe friday 
 -- 
 david b. lewis		temporarily at but not speaking for visual, inc.
 day: dbl@visual.com	evening: david%craft@uunet.uu.net
 